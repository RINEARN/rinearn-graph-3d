# やる事リスト

※ 自戒: あまり枝葉の設計で肩肘張り過ぎて実装が鈍らないように。まだゴールは果てしなく遠いので、とにかく何かしら書き進める。取っつきやすそうなタスクをここに切り出しつつ。

## ちょっと思いつき 20250202, 04, 13, 17

* Vnano.jar、内蔵の数式プロット機能（外部スクリプトではない）に使ってるからもうエンジン自体も RinearnGraph3D.jar 内に入れ込んでしまった方がいいのでは？
  アプリ内に RinearnGraph3D.jar を組み込んで使う用途で、一発でいけるようになる。現状だと lib/app-dependency から Vnano.jar も引っ張ってこないといけない。
  で、RinearnGraph3D.jar を組み込む用途だと、数式も描ければ描きたいだろうし、 Vnano.jar も大抵は居るでしょ。

  * 確かに。標準プラグインはどうすべき？
    -> 同じ理由で Math 系は RinearnGraph3D.jar 内に入れといてもいいかな。
       ぜんぶ使える必用はないけれど。追加で使いたいやつは自力で追加してもらえばいい。標準でよく使う数式プラグインくらいは入れといた方がいいかも。

    * VnanoConfiguration とかで設定できてもいい。GUIだと「Vnanoスクリプトエンジン設定」か。独自実装プラグインやライブラリはそっちで指定し、SET を押すと確認メッセージ出したうえで lib/VnanoLibraryList.txt とかを書き換える。
      無ければその時に「フォルダや設定ファイルが指定位置にありません」って出す。アプリ実装する人はそこで気付けるしそれでいいかと。

* 済: Configs の各 getter/setter の名前、「クラス名から分かる目的語を省いて短縮形にする」のか、それとも「メソッド名だけでも成立する形にする」のかまだブレがある。
  例えば現状 CameraConfig は前者だけど、LegendLabelConfig の setAutoLegendGenerationEnabled とかは後者。
  で、CameraConfig の setAngleMode とか setVerticalAngle はちょっと削り過ぎな気がしないでもない。そこは setCameraAngleMode の方がいいかもしれん。

  -> いやーでも LegendLabelConfig の setLabelText とかを setLegendLabelConfig にするのは明らかに冗長な気がするし、短縮形を基本にした方がいい気がするけどなあ。

     -> しかしまあ、たぶん setVerticalAngle とかは、カメラの位置を指す角度なのか、視野の角度なのか、それが分かり辛い。
        なのでこの命名自体がそもそも悪くて、それによる違和感な可能性もある。
        結局「何の角度なの？」ってのが、CameraConfig の中にあっても曖昧に感じるわけでしょ。そこにメソッド名の中に Camera を付けてもたぶん完全解消はしないよ。

        例えば、 setPositionVerticalAngle とかなら普通にいい気もする。
        つまりこれはそもそも脳内で Camera を補っても変だから違和感がある。
        CameraConfig の setScreenWidth を setWidth にしたら変になるのと一緒。Camera の Width って何やねんって話になるやん。その違和感や。

        * ああ確かに。そっかそうかもしれん

        * CameraConfig の angle 系 は、2024/02/15 に上記の通り setPositionVerticalAngle とかに変えた。
          これをさらに setCameraPositionVerticalAngle とかにすると明らかに冗長すぎるのし、
          cameraConfig.setPositionVerticalAngle でしっくりくるようになったので、まあこれでベストか。

          つまりやっぱり「クラス名から分かる目的語を省いて短縮形にする」が基本でよくて、それで違和感があるやつはそもそも命名がまずいかもって感じか。

* 済: EnvironmentConfiguration, SystemConfiguration とかに変えるべき？ というか命名時も絶対思い浮かんだはずだけど、なんで採用しなかった？
  綴りが長て読み書きコスト高く、非直感的で抽象的な命名で、さらにメッセージの言語ロケールの取得とかで頻繁に参照する。もうちょいなんとかすべきかも。

  -> いやでも走りながら考えてきたらやっぱUIでは「環境設定」即ち「Environment Settings」が良い気がしてきたし、
     それだとコンテナが EnvironmentConfiguration になるのは妥当な気がする。
     UIでメニューに「環境設定」と「システム設定」がある時、どっちが分かりやすいか？って話。日本語/英語とか切り替えるのに。前者では。

2025/05/17 に RendererConfig を作ってそっちに移した:

* 済: config.camera の RenderingMode、存在位置か命名のどちらかを変えるべき。以下コード内NOTE抜粋：

   * この命名だとここにあるのがおかしい、なんか別のコンテナ作るか改名を考える。
     そもそもこれはカメラの設定ではない可能性すらある。レンダラーの設定では。
  
     * 確かに命名か位置のどちらかが明らかにまずいというのは明らかにそう
  
     -> ただ、RendererConfiguration とか作ると、renderer パッケージ管轄で閉じてる config がある設計か？って雰囲気になるかも。
        実際のところは、config.* 内の多岐に渡る configs をレンダラーは参照しながら描くので、あえて RendererConfiguration ってのを作るのもまずい。

   * そもそもここでの動名詞も避けたい気もする。

   * 確かこれってそもそも setAntialiasingEnabled みたいな案から始まって、でも単にアンチエイリアスON/OFFだけじゃなくて、品質重視か速度重視か、もしくはバランスか、
     みたいな選択の方が将来的によさそうって考えての結果だったと思う。そこに RenderingMode みたいな仰々しい名を付けてしまったのが間違いだったか。

  コード内コメントにも関連した話がある。以下、CameraConfig のコードコメントから抜粋：

   2Dの方には Camera って概念が無いので、screenWidth とか renderingMode とかは別の config を作って移しておいた方がいいかも。
   2Dと3Dのライブラリとしての対称性を上げるには。

 * そうすると magnification, distance, angles, rotationMatrix がこの config 管轄として残る。
   まあ3Dのカメラってそうな気がするしそれでいいか。

 * 問題はその新しい config をどう命名するか？ RendererConfiguration は粒度が大きすぎる。だってレンダラーは他の config も読むし。

   * スクリーンサイズとかジオメトリだけなら ScreenConfiguration で、アンチエイリアスもギリ入れられるけど、
     しかしアンチエイリアス以外に色々な画質も変化するようになったらもはや ScreenConfiguration ではないよねってなる。
     そういう点では RendererConfiguration がいいんだが…

     * ScreenConfig と RendererConfig 両方を用意して分ければいいかも。
       ジオメトリは ScreenConfig に入れて、画質とレンダラーモード（標準かカスタム実装か）とかは RendererConfig にすれば、RendererConfig の存在自体はそんなに気にならない。
       他のワイド設定ではなく、本当にレンダラーそのものをどうするか＆レンダラーのオプションとかの設定なので。
       で、2Dでも ScreenConfig と RendererConfig の2枚構成は普通に成り立つ。

 * 済: UI上はどうする？ 別にUIと config コンテナの構造が一対一対応でなくてもいい（むしろそれぞれで最適を探るべき）なのは過去の議論の通り。

   -> カメラに入れてしまってもいいけど、カスタムレンダラーの選択とかを入れる事考えたら、別の新規ウィンドウを作ってもいいかも。
      あと、2Dの方でも同じウィンドウ作ってそこにスクリーンとかアンチエイリアス系の設定とかする感じで。

   -> 将来的には上記でも、現状は 5.x と似てたほうがユーザーが移行しやすいし、UIはとりあえずカメラ設定に入れといたままでいいのでは。
      6.1 とかでカスタムレンダラーをサポートした時に、初めてレンダラー設定画面を作って、そこに画質オプションを入れ込むとか。

      -> しかし画質のON/OFFってそんな切り替える人居ないし、いま画面作って入れてしまってもいいのでは。
         滅多に操作しないし、久しぶりに切り替えるにも「どこにあったっけ」ってなるレベルでしょ。
   
      * スクリーン設定は現状通りGUI上ではカメラの所にあっていいと思う。2Dだと余白の調性とか居るけど、3Dだとほぼスクリーンサイズくらいだし。
        なので長期的にもカメラの所に一緒にあった方が便利かもしれない。わざわざ画面幅・高さだけ別ウィンドウに分けるってのもGUIでは過剰整理な気がするし。なにより 5.x を踏襲できる。

* 済: RendererConfig の RenderingMode、RendererConfig という枠を作ったならもっと細かい粒度に再分割してもいい気がする。
  CameraConfig 内ならこういうモードで代表させるのはアリだけども、RendererConfig 内なら漠然と大味すぎる設定になってしまう。

  例えば、setAntialiasingEnabled とか、setSmoothShadingEnabled とか、それぞれ明示的に調性したい場面もあり得るだろうし。
  実際、本質的に滑らかじゃないデータだと surface プロットのスムースシェーディングはOFFにしたいけど、枠線とか目盛り数字とかの見ばえからして Antialiasing は ON にしたいっていう場面はあり得るでしょ。
  それが現状仕様だと、RenderingMode=QUALITYにすると両方ONになって、RenderingMode=SPEEDにすると両方OFFになる、って挙動になってしまう。簡単だけど細かい調整ができないデメリットも大きい。


済: 2025/02/13 に改名済み
* config の OptionConfiguration 、UIとは乖離するけど PlotterConfiguration の方が意味的に適切では？
  Option は曖昧だし、その気持ち悪さはUIでも生じてるけど、UIは所見での分かりやすさ優先でそうなってる。でも、API の config までそれを引き継ぐ必要はないような。

  実際、既にAPIでは意味管轄ベースで整理してて、UIのプロットオプションの内のいくつかは、他の config のオプション的な項目を ON/OFF するようになってる。
  具体的には、グラデのON/OFFはColorConfig内のオプションのON/OFFだし、凡例のON/OFFは LegendConfig 内オプションのON/OFFだし。

  このように、オプション相当の設定値が既に各種の意味管轄 configs の中に分散している状態なので、
  OptionConfig っていうUI対応重視の命名をする必用ももう薄い気がする。

  で、PlotterConfig だと、意味管轄としてマッチするし、UIのオプションの中でプロットオプション系のやつは PlotterConfig にあるよって書いとけばわかるでしょ。
  むしろ「ある項目がGUIの オプション メニューにあるのに、APIの OptionConfig」には無いぞ？？？ という混乱を避けられる。必然的に意味ベースで探す事になるし。

  * 確かに妥当な気がする。いっそUIでも「プロッター/Plotter」メニューにするとかは？

     -> それは所見での意味不明さを上げてしまうと思う。
        プログラミング時の概念ベースの思考にはマッチするけど、GUIだと視覚ベースなので知らん単語をトップメニューに出したくない。
        オプション/Option は見慣れた語だし、そのメニューをクリックして一覧見れば「あーそういう事かー」ってわかるし。

        極端な例として、意味不明な抽象概念的な単語が並びまくってるメニューって慣れるまでだいぶ辛いでしょ。

     -> GUIの「オプション」メニューには、プロッター以外にも便利なオプション系を並べてるし、多少意味的に散らばってるけど、GUIはそれでいい。
        なので「プロッター」にすると逆に意味を絞り込みすぎになる。現行GUI上では。

        APIは将来互換を重視したいので、仕様の安定性を考えると意味管轄で整理していきたいけど、
        GUIは直感的な使いやすさを考慮してメジャーバージョンアップで揺れたり変わったりもしていくし、むしろそれを探るべきでもあるので、APIに無理に合わせなくていい。

        で、「オプション」メニューに頻繁に使いそうなON/OFF項目を雑多に放り込んであるっていうのは、リニアングラフがそこそこ使われてる事の大きな理由の一つだと思う。
        GUI上はたぶんだいぶ当たりの案で、そこ変えるのはリスクがある。特に所見で意味不明になる方向だし。

        APIはあくまでも将来互換を考えた概念空間での整理。GUIとは究極的には別物として割り切ったほうがいい。やりすぎる必用はないけれど。

   * ああそうそう、カスタム Plotter 実装 implements PlottingListener をどこに登録すんのって考えたら、
     PlotterConfiguration があるとすっきり当てはまる。そうじゃないと、なんかそれだけの config 管轄が別に要るようになってしまいそう。
     他にカテゴリ合いつつほどほどの粒度にまとまる管轄ってイメージし辛いし。

     * それ考えると、現状の「カスタムオプション」は名前を変える必要があるな。APIで CustomPlotter にしてしまうと非常にややこしい。
       あれはカスタマイズ性が高いプロットをGUIにかぶせたコマンドベースでやるものだけど、APIでの Custom は現状の他整合ではカスタム実装を意味するので。

       -> あのコマンドベースの記法、VCSSLよりもより簡易なプロットスクリプトの記法として将来使うかもって想定もして設計したので、それ踏まえて命名しなおしてもいいかも。
          またその際に要検討。

* 済: SimpleRenderer.configure の中で SimpleRenderer.updateGradientColors 呼んで
  そこでグラデの座標範囲が（オートレンジON時に）更新されてんの、管轄的におかしくない？
  「とにかくグラデを描く所まで到達するための投げやりの足場実装」だったのが、そのまま残ってる可能性がある。

  普通に考えて、もっと上層で処理する必用があるでしょ。replot 処理の一部として。
  RangeConfig のオートレンジと同じくらいの所で。
  renderer の内部でグラデの範囲とか書き換えちゃいけないよ絶対。

  -> Presenter.adjustRanges の中で行うように変更した。


以下は2025年2月15日に実施済み:
* 済: configのやつら、やっぱ内部クラス/enum入れ子にするのやめて全部サブパッケージに展開すべきかも。
  当初はコンパクトさ重視でよかったかもしれないけど、やっぱ scale config とかで無理が生じてサブパッケージ作ったし、
  それならもう全部サブパッケージにした方がいいような。例外がある時点でもはやコンパクトじゃないし。

   * サブパッケージを原則作るなら、～～Configuration みたいなやつも /～～/サブパッケージに移すべき？
     config 直下ではなく。部品の import 要らんし本来そうあるべきな気がする。

  -> しかし config パッケージに並んでるやつだけで一応は設定に必用な主役が一覧できるのはいいんだよなぁ

     -> 結局そことの兼ね合いが一番大きい。どうしよう。少し考えるべき

     -> しかしconfigは実装管轄というよりAPI管轄の役割が大きく、互換サポートでずっと基本構造残るからな。

        後になって、「最初すし詰めにしようとしたけど行き詰ってあちこちサブパッケージに漏れてる」みたいな代物になる可能性は結構ある。
        正式リリースまだ遠いのに、もはや行き詰まりが見えているので。上記を貫いてまとめるのははもはや叶わぬ夢なのでは。
        
     -> 上記に加えて将来を考えると、6.1, 6.2 と版を重ねるごとにたぶん色々増えていく。
        だって、カスタマイズ性を増す際には、たぶん config に色んなクラスを生やすという事が伴いそうなので（例: Ticker 導入時の流れについて考えよ）。
        で、その時に、例えば AbcConfig 管轄の拡張でサブパッケージ /abc/ 生やしてクラスや enum 置いたら、
        AbcConfig の「中」に既に定義されてる内部クラスや enum が非常に微妙な立場になる。まさに「かつてすし詰めにしようとして破綻した名残り」。

        -> それは確かにまずい

   * うん、やっぱもうサブパッケージ基本にすべきだろう。枝が生えちゃってる時点で。
      念のため少し塩漬けして、問題なければ次のリファクタのタイミングで Go か
  
  -> RangeConfiguration みたいな中ボス級のやつまでサブパッケージに移すのは慎重になった方がいいかも。
     パッケージ内に RangeConfiguration と AxisRangeConfiguration があたったら汎化/特化の関係を想定するでしょ普通。
     しかしその命名問題をクリアすんのは難しい。現状の内部クラスなら構造的に自明だが、フラットに展開すると問題になる。

     -> 確かに。とすると、サブパッケージに移しつつ、AxisRangeConfiguration みたいなやつは内部クラスのまま、っていう手もあり得る。

     -> いやそこはもう汎化/特化の関係じゃなくてもいいでしょ。設定コンテナなんだし、サブカテゴリ―の設定みたいな感じで伝わるでしょ。中ボス名が大枠で。

* 系列番号の 0 始まり or 1 始まり問題。
  「APIでは 0 始まりで、UIでは 1 始まり」という案について再考したほうがいいかも。
  UI で 0 始まりがあまり問題にならないようなら、APIと統一できた方がうれしい。
  あと、系列番号を時刻と見なす場合などに、0 始まりは都合がいい。

  -> でも我々にとっては自然でも、普通は「0番」って特例でしょ。正式版でないプロトや、特別な枠に与えられる。
     「普通のやつ」を数えるのは 1, 2, 3 ... でしょやっぱ。普通の感覚では。
     プログラマはもはや0番の不自然さに気付けなくなってるけど、相当変だよたぶん一般には。

  -> あと 0 始まりだと、N個系列がある場合に、最大の系列番号が N-1 になる問題もある。
     むしろ一般層の違和感はこっちの方が大きいかも。5系列のファイルで系列番号が 0 ～ 4 って。たぶん慣れてないと「何それ」って絶対なる。

     で、API叩く人はもうそのへんは分かってるんだから 0 始まりでいい。UIで 0 始まりはやっぱアグレッシブすぎる気が。
     間の層で吸収してでも 1 始まりの方がやっぱよさそうな。

   * ならいっそAPIでも 1 始まりにするのは？

     -> それはデータストアや構造配列のインデックスと系列番号を同一視できないという事になるので、あまりにも開発のネックになる気がする。
        まあ、内部での系列番号は 0 始まりにしつつ、APIの引数だけ変換するってのはできるっちゃできるが。

        * あ、最後の、それいいかも。RinearnGraph3Dとかの層で、モードで 0 始まりか 1 始まりか指定できるようにしておいて、
          それに応じてAPIの入口出口で変換する（またはしない）。それでいいんじゃ？

          * 確かにそれはいい。それなら、現状は「APIでは 0 始まりで、UIでは 1 始まり」の方針のまま実装を進めて、
            どっかの段階でモード作ってAPIに一枚変換を嚙ませればいいだけだし、開発進行のネックにもならない。

     -> RinearnGraph3DDrawingParameter に既に set/getSeriesIndex() がある。この番号に応じて彩色されるから、互換を保つ必要がある。
        まあこれは上記の「モードによる切り替え」案で対応可能。しかし描画エンジン層とソフト本体はそれぞれ独立なモードにすべきかもしれん。
        描画エンジンの直接制御って、用途が普通とはだいぶ違うので。とにかく書いた時のまま動いてくれ、みたいなやつは存在し得そう。

        -> ああ確かに。まさに「ソフトの内部実装は 0 始まりでいきたい」というのと同じ事情が、描画エンジンの制御コードとかでは生じ得る。
           というか本来ソフトの中の処理を、カスタマイズ性のために外からいじれるようにAPI切ったのが描画エンジン制御APIだし。
           「外」か「中」かで言ったら中のコードに近いか。たとえユーザーコードも。
           なら確かに描画エンジンでは本体と独立にモード切替えできる必要があるな。


## 気付いた事（対応が必用な事）

* 済: CameraConfig に validate() 実装してない。LightConfiguration も。
* 済: FrameConfig を内部クラス分離してない
* LightConfig の中の ambientReflectionStrength の Strength ってなんか微妙かも。要再検討

## 済か？ でもまだ新たに浮上はしそう） ネイティブ的に変な命名を直す（旧名も互換を保ちつつ）

* 済: ルートAPIの set~AutoRangingEnabled 系は明らかに変っぽいから set~AutoRangeEnabled にする
* 済: setAutoDisposing/ExitingEnabled も名詞にする
* 済: setAsynchronousPlottingEnabled は意外と名詞にしない方がいいのでは？ みたいな感じらしい。あと PlottingEvent と PlottingListener も。なのでこれらは現状維持。
* 済: RenderingParameter の setAutoColoringEnabled, setRangeClippingEnabled, setRangeScalingEnabled もそれぞれ名詞にしたほうがいい。
* 済: 上記の改名後の setRangeClipEnabled, setRangeScaleEnabled については、そもそも論として、より適切な命名があるのでは？ Range の箇所がちょっと微妙。まあ目盛りのスケールとの混同を避けるために何かしらは要るが。 -> かなりがっつりと再検討した結果、結局は改名前の setRangeClippingEnabled と setRangeScalingEnabled が十分よくてベストに近く、この場合は動名詞も自然で、それなら変えるデメリットの方が大きいので現状維持の一択になった。という事で結局これらは元の命名に戻した。現状がベストと迷うくらいの自然形なら、後でどうしても変えたい場合になってから変えてもいいし、そして恐らくその時は来ない。なお、 setAutoColoringEnabled については、再検討したがやはりだいぶ変なので setAutoColorEnabled への改名は正しいという結論になった。
* 済: DataFileFormat の enum 名、あの場合の COLUMNS は単数形の方が適切っぽいので単数形に直す

## メニューの実装を進める

* 済: 「設定/Settings」メニューをやっぱり 5.x 同様の「編集/Edit」メニューに戻す。だって、設定って言ったらオプション設定だって設定じゃんってなるし。
   レンジとか色とかを変えるのが「編集」、プロット方式のON/OFFやよく使う二択項目を並べたものが「オプション」メニューで、これらひっくるめて両方「設定」。
   逆に言うと、設定を一つのメニューにまとめずに、利便性を考えて2通りに分類したのが、リニアングラフ3DのUIの（いい意味での）特色でもあるとも言えそう。偶然だったけど。

* 済: ラベル設定ウィンドウに凡例の設定UIを増設する
* 済: 基本系のプロットオプション（点、線、メッシュ、曲面）
* 済: グラデーションオプション、これは ColorConfig の GradientColor の状態を書き換える
* 軸反転とか対数軸とかのオプション。これは ScaleConfig を書き換える。ScaleSpaceConfig みたいなんが新規で要る？
* 等高線オプション。これは現状とりあえず 5.x のコードからそのまま移植でいい。あれ掃除するのはたぶん大変で、コーナーケースがたくさんあるから用意周到にやらなきゃだし。現状ちゃんと動いてるし、閉じてる処理だから中をいじる機会もほぼ無いし、なのでとりあえずそのままで。中をいじる機会がある時にまた検討する。

## API系の5.x互換レベル到達を急ぐ

* GUI含む全機能の完成にはまだ距離があるが、APIだけでも5.x互換なレベルにもっていけたら、とりあえずグラフ描画ライブラリとしての用途はカバーできる。そっち方面の展開は正式リリース前でも進められる。ので効果としてでかい。優先的に急いで推進すべき。
* 描画エンジンの文字列書くAPI。エンジンを組み込みに使ってるユーザー層が（少ないが）存在はしているので、とりあえず描画エンジンAPIだけでもオープンソースで全用途カバーしたい。そしたら簡易3D描画ウィンドウとしてはとりあえず使えるようになる。

## 描画関連を最低限実用できるあたりまで充実させる

* 済: 凡例が空文字の要素は描かないようにする？ -> まあマーカーだけ書いても意味ないしな… 空行を入力する意図って、描きたくないからな気はする。
* 済: 上記を実装した結果、空の凡例の位置に空白が空くので、それを詰めるオプションがほしい。

* 済: 上記を実装してみたらさらにちょっと変えたくなった： ONなら空の凡例を描かずに間隔も詰める。OFFならマーカーのみ描く。実利を考えたらこの二択の方がいいんじゃないかと。
  -> そうするとフラグの命名も変わる。emptyLegendRemovalEnabled か？
     -> いやそれだと、「空の凡例を設定から除去する」的なニュアンスも出てしまうのでは。つまり legendTexts[] 内の空行の除去みたいな。もうマーカーのみ描いてても「Gap」扱いでいいんじゃないの？ 見た目的に空席みたいなもんでしょそれらは。

* 上記を実装したけど、やっぱりマーカーがあるとGUIの「隙間を除去」の「隙間」が意味するものが謎い。マーカーが無いと、「ああそこの隙間ね」って納得できるんだけど。やっぱり命名再考が必用か。
  -> UI でしっくりくるのは「 空の凡例も描画 / Draw empty legends 」でしょ。で、その config フラグ相当の命名がちょっと問題か。
     -> setEmptyLegendVisible とか? Enabled命名とはちょっと違うけど、可視/不可視のフラグを visible 命名にするのは ScaleConfig でもやってるし、自然ではある。
        -> それいいかも。
        -> いや、意味的に setter が is～ じゃなく are～ になりそうじゃない？ 対象のLegendって一般に複数なので。
        -> いやいや、この場合は 1 個の状態フラグで集合の扱いを一括設定/取得してるので is でいい。are は配列とかリストとか返す場合に稀にあるが、相当レアでしょ。ここは is が普通。
   -> どんでん返しで setEmptyLegendExclusionEnabled が有力候補に。やっぱり凡例は「全部描く」のが基本動作で、そこから「空の凡例のみ除去する」という追加アクションとするのが自然だし、系列フィルタの include との対応もとれてる。

* 済: カラーバーを描く
* 済: 凡例を描く。これは 5.x にはないので色々と考察検討が要るかも
* アニメーションとかだと系列数が膨大になるので、凡例としてどういう形が適切か？ を考える。少なくともそれを考慮すると、凡例は「大系列ごと」か「小系列ごと」かのモード切り替えが必要になりそう。
* 上記に付随して、場合によっては系列の階層を増やす必要があるかも。DataSeriesGroup はファイル1個や z(x,y,t) 数式1個に対応するので(contains multiple DataSeries)、それをさらに包む構造が… しかし名前がややこしいなそれたぶん。
* 済: プロットオプションの系列ごとの設定対応。各系列ごとにオプションを選ぶよりは、逆に各オプション画面でそれぞれ対象系列を指定する方がこのグラフソフトにはマッチしそう。こないだ考えた通りに。
* プロットオプション、上記方式だとややこしい場面（各系列ごとにオプション指定したい場面）はカスタムプロットみたいなコマンドインタープリタ on GUIでカバーすればいい。普通のGUIメニューで組むと、デフォルト状態のUIからのシームレスな拡張にならないので混乱が大きそうでメリット少なそう。

## 数式関連を最低限実用できるあたりまで充実させる

* 済: 各数式のプロット画面、新規プロットだけでなく更新を可能にする。UIどうすべきか考える必用がある。
  (現状はそのあたり考えるのが面倒なので「OK」押したら消えて、また開いたら追加、みたいな挙動にしてる)
  -> 起動時は「PLOT/プロット」ボタンにして、その後「UPDATE/更新」みたいに変化する感じでいいのでは？ んで ↓ の編集時は起動時点から後者モードにする。
* 済: 既存数式を選択して編集できる仕組みを実装する。「ファイルを開く」UIのような画面か、それともメニュー項目からの単純なセレクトボックス表示か。どっちがいいかな。
  -> 「ファイルを開く」UIはファイルパス列をコピペしたい場合を想定してあの形にしてるけど、数式は離散化数とか範囲とかの項目もあるので数式だけでは決まらないし、あのUIにしてもあんまりメリットないような。テキストエリアじゃなく「リストUIをクリックして編集画面を開く」みたいな挙動にするの必須だし、その方向の独立ウィンドウの完成系はむしろセレクトボックスのダイアログそのものでは。
* 済（実装も）: 「x(t),y(t),z(t)」形式の実装について考える。変数 t をアニメーションモードとどう整合させるべきか。もしくは t を避けて s や i にするか。-> i は将来的に複素サポートした時にややこしいので n か。-> いやしかしここでの t は整数じゃなく実数でしょ。i や n はまずい。線素の累積だし普通に s でいいんじゃないの。どうせこんなんプロットすんの理工系の人だし線積分やってるでしょ。伝わるって。むしろ t よりも。t は微分方程式くさいし s の方がむしろベストな気もするし。 -> いや線素の累積値ちゃうで。線の周辺なぞる長さのディメンションには対応してないやろ。依存してるだけや。まさに動きにおける t 的な量や。属するディメンションが全然ちゃう。 -> ああ確かに、どうすっかな -> アニメーションのTRACEモードは座標点 i を t = i * Δt where Δt = timeRange/N と見なしてアニメーションするモードやし、プロット画面で「アニメーション」を選んだらアニメーション画面をTRACEモードで開いてΔtの値を通知セットすれば何も問題なにのでは？ どこも概念的な不整合はない。TRACEモードの想定概念そのもの。 -> 確かに。じゃあ問題は z(x,y,t) の方か。-> z(x,y,t) も「系列を時系列と見なしてプロット」の想定概念そのもので、Δtを適切に通知転送すれば何も問題がない。-> 要は両者でアニメーションモードが違うというだけで、同時に両立はしないけども、アニメーションモードと概念矛盾はしない。z(x,y,t) と x(t),t(t),z(t) を同時に同じ t でアニメーションさせられないというだけ。それはちょうど、異なるアニメーションモードを想定したデータファイルを、同時にアニメーションさせられないのと同じ原因で、数式自体の問題ではない。アニメーションモード側でそういう仕組み（複数モードのシンクロナイザみたいなもん）を作るかどうかの問題。 -> 確かに。じゃあここではとりあえず安心して Ver.5.6 と同等の処理をするツールをそのまま組み込みで実装すればいいだけか。あとの改善や割り切りはアニメーションツール実装時の管轄で、今ここの実装の段階で悩む必用はない。素直に Ver.5.6 の正常進化形でやればいい。安心納得。
* 同様に「z(x,y,t)」についても考える必要がある。上記と同時に考えるべき。-> 考察は着地した（上記参照）。素直に複数系列のメッシュを生成すればいい。-> 凡例がどえらい事にならん？ -> ああ… なんか特例が要るかな。 -> いや、凡例はファイルごとに付くし、ファイルは複数系列を含み得るので、大系列ごとに付けられるようにすればいい。そういう仕様にすれば、z(x,y,t) は t ごとに異なる系列を含む大系列が1つなので、凡例はすっきり書ける。凡例のオプションで「大系列ごと」か「小系列ごと」を選べるようにすればいい。 -> つまりこれも凡例の実装側で悩む管轄の話で、この数式ツール実装の時点で悩む必要はない。
* 数式は設定ファイルで保存できてもいい。ファイルパスとは違って外部に依存せずソフト内で閉じてる情報だし、特定の数式を色んなファイルに重ねて表示したいような解析シーンはよくあるし。将来的に。

## 全て済み: ファイルメニューを最低限実用できるあたりまで充実させる

* 済: 「ファイルを開く」のメニューのUI、とりあえず 5.x ほぼそのままで実装（ここは特に不満ないし）
* 済: 「画像のコピー」メニューの実装
* 済: 「画像の保存」メニューの仮実装
* 済: 「画像の保存」メニューの本画面＆イベント実装
* 済: スプレッドシートからのデータの貼り付けメニューの仮実装
* 済: スプレッドシートからのデータの貼り付けメニューの本画面＆イベント実装
* 済: 上記で、各テキスト関連UIでのコピペメニューをどの方向で実装するかの検討も済ませる。そしてそれを他のテキストUIにも適用。

## 全て済み: データファイルを開くフローの仮組み

* 済: データ系列の内部表現の確認
* 済: ファイル由来データ系列の内部表現の検討（確か既に作ってたはず: ArrayDataSeriesとか）
* 済: 仮の即席実装として、とりあえず3列ファイルとかから上記を生成するデコーダ書く
* 済: openDataFile 系のAPIを実装し、コードからファイルを渡して読ませてプロットしてみる
* 済: データを保持・管理するデータストア的なオブジェクトを作って、Model直下のデータ系列をそれを介するようにする。
* 済: 範囲の自動調整が ON の場合に、自動で範囲を検出して合わせる処理を実装する
* 済: メニューバーに暫定的な「データファイルを開く」とかのメニューを増設し、そちらからでも開いてプロットできるようにする（まだUIは凝らない）
* 済: このあたりでマトリックス書式のデコーダも実装してしまいたい。そうすればとりあえずは何かに使えるようにはなるので。Ver.3.x 世代相当くらいにはなる。細かい枝葉で全て5.x以上をいきなり目指すより、まず何かに使える状態に着地させてから拡張していったほうが多分いい。

* 以上で、データファイルを開くフローの（仮の）骨組みが一応できるので、そこで俯瞰して細部を再検討して直したり次を考える


### 脳内議論

↓ 実装した。様子見が済んだら以下は消す

* データI/O周りを書く上で、複数の DataSeries をまとめる DataSeriesGroup みたいなコンテナが欲しいかも。要は大系列の構造。一つのデータファイルに複数系列が存在し得るので、そういう単位のコンテナとしてほしい。

    ↑ List\<AbstractDataSeries\> に対する優位性は？ 結局要素と count 持たせるだけになる気が。

    ↑ データ群をファイル群に紐づけて管理する場面は多分そこそこ生じるが、上記の構造が無いと List\<List\<AbstractDataSeries\>\> とかになってしまって、コメントで説明してもコードがややこしすぎる。「トップ階層がファイルのリスト、その次の階層が各ファイル内のデータ系列のリストで…」とか。上記構造があれば List\<DataSeriesGroup\> fileDataList とかでストンと収まる。

    ↑ ならついでに系列名の保持とか対応付けとかも行うのもありか。→ いや系列名はむしろ個々の AbstractDataSeries が持ってるべきかと。

* 例外どうする？ I/Oで新しいの要るかも。まだ独自例外は作ってなかった。IOException を使ってもいいけど、データファイルの書式エラーとかは別種の例外が欲しい気もする。

    ↑ API の openDataFile とかは IOException を投げる仕様になっていて、互換考えるとそこで検査例外は増やせないので、どうせAPI表層では IOException でラップして rethrow する形になる。なので、内部処理のためだけに新種例外がほんとに欲しいか？ という話になる。どうだろ

    ↑ 内部処理で、ファイルアクセスに失敗したのか内容が違ったのかでハンドリングを分ける必要は明らかにあるので、それを区別する上であった方が分岐をすっきりした形に書ける。

* 上記例外、作るなら例外用のパッケージにまとめる？ それとも model 内のそれぞれの場所に作る？

    ↑ model外から参照したい場合もあり得るので、model外の独立パッケージにあると後々で詰まずには済む。model 内定義だと、なにかの拍子に view 側で拾ってチェックしないといけない場面が（無いのがベストだけど）もし生じた時に疎結合を破る事が避けられない。

    ↑ しかし普通は例外だけパッケージにまとめるってのは変で、それ使うパッケージに属してるのが多いような。APIで投げるならともかく、先の議論の帰結として内部処理用にするならなおさら。

    → むしろ独立パッケージって config パッケージみたいにAPIから使う用を兼ねてるみたいな雰囲気が出てしまうような。このソフトだと。

    → まあ内部専用なら互換気にせずに後でどうとでもできるんだし、とりあえず model 内に、その例外をメインで使うサブパッケージ内のその場で作っておけばいいかと。ととりあえず。やってみて微妙ならその時まとめるとか。

* Config 系の validate で検査不合格になった時の例外、現状は IllegalStateException とか投げてるけど、そこは RinearnGraph3DConfigurationException とかあってもいいかもしれない。実質 configure API呼ぶ時に catch しなきゃいけないし、IllegalStateException はワイドすぎるような。config は正しいけど読む側がぶっ壊れてるのと区別つかん。


↓ 実装した。様子見が済んだら以下は消す

* データファイル書式の自動推定、Ver.5.6 → 6 でリフレッシュしたいけどアルゴリズムどうする？ デリミタ判定 → 列数とか空行構造から書式判定、の流れだけど、まずデリミタ判定をどうするか。

    * 5.6 のデリミタ判定は確かCSVとSTSVの両方で仮に部分パースしてみて列数が多い方を取ったりしてたような。無駄に処理コスト高い気がするけどなんでそうしたんだっけ。

    * とりあえずはデリミタ判定は、空行＆コメント行以外が全てカンマを含んでたらCSV、そうでなければSTSV、の二択か。これはすぐ思いつくが果たしてどうだろ。

    * strict な TSV とかサポートした時にSTSVとTSVの区別が付きやすい方式の方がいいかも。

        ↑ そんなら左側3列が常に数値である事を用いて (数値)(デリミタ)(数値)(デリミタ)(数値) って並んでるはずだから、そっからデリミタを抜き出す？ 最初の有効行とか仮読みして。

        ↑ しかし数値が浮動小数点数だからストレートで正規表現マッチするのはコスト的にもエグさ的にもなんか嫌だからな。あり得る全てのデリミタで split してみて間が数値かどうかを見るか。逆に。

        → CSVでも strict TSV でも判定いけるし、STSVも「TSVと見なして切ってみた時に空白混じってたらSTSV」という判断でいける。結構シンプルでよさげかと。

        ↑ なんかそれだと結局 5.6 に近い。そういう事だったのか。

    * 上記をもうちょっとひねって、「カンマで切ってみて左列にタブか空白が混じってなければCSV、混じってればCSVではない」→「CSVじゃなかった場合、タブで切ってみて左列に空白が混じってなければTSV、混じってればSTSV」みたいにいけるのでは？ カラム値が必ず数値である事を利用してはいるが、数値判定自体は行わずに軽い空白混入判定のみでいける。 → これを実装した



↓ 実装した。様子見が済んだら以下は消す

## リファクタ: ArrayDataSeries[] 配列を引数にとってる箇所を DataSeriesGroup を使うようにする

* Model層とかである。setArrayDataSeries(ArrayDataSeries[] allArrayDataSeries) とか。やっぱ Series が複数形でも同一語なのが少しややこしいし、今は別の事情で DataSeriesGroup というコンテナができたので、もう配列じゃやなくそっちに詰めたほうがわかりやすい。

    ↑ しかし、DataSeriesGroup は abstract class な DataSeries を要素に持つので、型が少しゆるい。上記は Math プロット系じゃなくデータ配列やファイル由来の ArrayDataSeries をまとめたいので、DataSeriesGroup に詰めてしまうと要素参照で毎回型検査が要る。

    ↑ なら DataSeriesGroup をジェネリックな型にするか？ → 明らかにそうした方がいいような。abstract で詰めたきゃ <DataSeries> して、Arrayに限定したけりゃ <ArrayDataSeries> にすりゃ済む話だし、たぶんやって得しかない。→ とりあえず上記の通りジェネリックにした


↓ 実装した。様子見が済んだら以下は消す

## データストアの実装

現状は Model 直下に各データ系列が保持されているが、データストア的なオブジェクトを作ってそれに保持・管理させた方がよさそう。なぜなら：

* 現状だと、データ系列の setter / adder / getter 類が Model に直接生えまくって見通しが煩雑
* 同上、範囲の自動検出とかのメソッドも Model に生えていく事になるし、その処理を Model 直下に実装するのがそもそも微妙
* かといってデータ系列を public final 化すると、add の時に関連更新処理をフックとかを（将来的にやりたくなっても）できないので、検討はしたけどやっぱNG判断になった
* 他にも、後々でデータ変換機能（対数軸とか、式での変換とか）を実装した時に、登録されているデータ系列から一枚変換層を噛ませて使う必要がどうせ生じそう。それをデータストア的なものの内側で包んで行ってしまえば、外から参照する際は気にしなくていいので、実装時もメンテ時も楽

以上を俯瞰するとどこかのタイミングで必須に思える。ので、範囲の自動検出を実装してるいま行ってしまった方がいい


↓ 実装した。様子見が済んだら以下は消す

## リファクタ: DataSeriesGroup を Iterable 対応する

拡張for文で使う時に getDataSeriesList() してるけど、これの登場頻度が多くて煩雑なので（思った以上にグループ要素をループする機会が多い）、DataSeriesGroup 自体を Iterable 対応してしまった方がいい。初見での可読性は落ちるかもしれないけれど、いちいちList引っ張りまくるよりはマシかと。



↓ 実装した（20250203）。ほぼ以下の意見を採用した。この意見は重要だったので、どっかに振り返れるように残しとくべきかも。少し塩漬けにして問題なければここからは消す

## !!! 緊急重要議題 !!!

* ColorConfig の設計、グラデとソリッドを対称性が高い扱いにして、系列ごとに「ソリッド」「グラデ」を指定してそれぞれの種別から円環的割り振りにする案、たぶん対称性が綺麗というだけであって実用性はかなり悪い。つまり設計時に何度も陥った単なる自己満足設計なだけの過剰な整合設計の可能性が高い気がするのでよく考え直せ。

* だって普通に考えてソリッドは何色も系列ごとに塗り分ける場面が多いから円環的割り振りになるけど、グラデでそんな数をさらに円環的な重複を含む割り振りで塗りたい場面がどういうケースであるの？ もしやってもその人は図の脚注とかでどう説明すんの？ MAXでせいぜい 2～3 パターンでしょ1図に含むグラデのパターンなんて。そんでその数なら円環的に閉じるのがそもそもおかしいんだよ。各グラデの設定画面で対象系列を数字で指定する方が絶対いいよ。ソリッドだとそれは使い辛いけどグラデだとその方が絶対使いやすいよ。つまりそもそも使いやすい塗り分け指定方法が対象じゃないんだよグラデとソリッドは。それを config 構造の対称性のために両方円環で同じ格の扱いにすべきじゃない。見誤ってる。

* で、さらにクリティカルな挙動例を示すと、グラデが一部系列のみにかかる場合に、グラデオプションのON/OFFによってその系列がグラデになったりソリッドに戻るわけだけど、それによって他系列のソリッドの色が変わるのは意味不明でしょ。でも各系列に対してグラデかソリッドかを指定していく内部config構造にすると、グラデのやつをソリッドに戻した瞬間に円環ルールによって後続のソリッドの使用色番号がずれて色変わるよ。それ防ぐには色割り振りをグラデとソリッドそれぞれ独立に solidColorIndex = seriesIndex % solidColorCount, gradientColorIndex = seriesIndex % gradientColorCount にする必用があるけど、これだと例えばグラデを2個定義していて、ある系列をグラデにする時にそのインデックスが偶数か奇数かで色違うってなって意味不明すぎるでしょ。式からすれば綺麗でもユーザーから見てほぼ壊れるレベルじゃん目を覚ませ。そこの式に綺麗さは要らん。

* んじゃ結局どうすればいいかっていうと、まずソリッドは solidColorIndex = seriesIndex % solidColorCount にする。これはグラデOFFな時に、ああ系列番号の順序と色リストの順序がシンクロしてんのね、足りんやつはもっかい頭から円環的に取ってくんですね、って事で極めて分かりやすい。2Dと同じ。これはまずOK。んでそこからグラデをONにすると、デフォルトでは全系列がグラデ対象になって全部グラデになる。で、そのグラデに系列フィルタみたいな属性があって、必用に応じてグラデ対象にしたい系列番号を指定する。その指定具合によって他系列のソリッドの色は変わらない。ここが極めて重要。これはソリッドのルールを土台として単独独立にまず決めて、そこに上乗せ的にグラデをかぶせているという概念構造だから。それを同じ格でパラレルにしようとするから逆にユーザビリティがトリッキーなる。

寝る前の思い付き書き記しなので粗いけど要検討。とりあえず現状は絶対変えろ。やばい。

-> いま上記について考えながら設計の改修を探ってるんだけど、系列フィルタを GradientColor の中に入れるべきかな？
   それとも GradientColor をラップする GradientColorConfig みたいなんで包んで、そいつに持たせるべきかな？

   ちなみに ColorConfiguration.gradientColors[] と同格で ColorConfiguration.SeriesFilter[] や ColorConfiguration.SeriesFilterMode[] を持たせるのはたぶんよくない。
   「ある GradientColor について、Mode を参照して INDEX なら IndexSeriesFilter を引っ張ってくる」みたいな場面で、
   上記の配列群全体を引っ張り出してインデックスであれこれキャストとかするの要求するのは明らかに筋が悪い。

   かといって ColorConfiguration 直下にそんなユーティリティのために getSeriesFilterModeAt とか作るのも冗長だし、そんなら何かで包んだほうがいいか、と。
   で、いっそ ColorGradient 自身にフィルター持たせてしまうか？ という一案が上記の意見。

   -> 抽象概念としてはグラデーション色が系列フィルター持ってるのはおかしいなあ。やっぱり。そこが一番の問題点。

      -> しかし多軸グラデを実現する都合で、既にグラデ次元軸を X/Y/Z/... とかから選べるようにしてるんだよな。それを ColorGradient が既に持ってる。
         これも直接「色」の概念ではないけど、多軸グラデするためにはどっかで持たないといけないもので。系列フィルタに似てる立場。

         -> いや、グラデの勾配が空間のどの次元軸かっていうのは、色の概念とは別だけど、「グラデの概念」には関わってるので、ColorGradient が持ってるのはそこまで変じゃない。
            だって向きのないグラデって実用上ないでしょ。グラデには向きがある。

            -> いや、「このグラデ」を「この向きに」かける、みたいな考え方をするし、やっぱ前者と後者は別の層に属する概念でしょ。
               「概念としての必要最小限まで削ぎ落したグラデ」ば向きとは独立で、それを実世界に適用する際に、「どの向きに適用するか」という操作が生じる。

               まあつまるところ、グラデはシールみたいなもんで、それ自体で向き未定のまま完成可能だけど、貼る際に向きを決める。
               -> 確かにその通り。その例でこの話は終わり。もうその通り。

         * それなら、GradientColor に次元軸の情報を持ってる現状を許すなら系列フィルタも入れていいと思う。
           逆に、系列フィルタを入れるのを避けるなら、次元軸の情報も別枠に分離すべき。この両者はやっぱりセットだ。

           この二択。さてどうする。

           -> GradientColor の設計見直してきたけど、GradientColor が AxisGradientColor のセットになってて、そいつが軸情報を持ってるっていう、
              命名も踏まえてうまいこと着地させた感があった。これを崩すと、せっかく着地してた問題がわらわらと以下のように浮上する：

              \* AxisGradientColor 相当のやつの命名をどうする？ 空間軸の概念と分離するなら名前を変えないと。
                 GradientColor1D とかにするなら、GradientColor も GradientColorND にしたくなるが。
                 逆に AxisGradientColor を単に GradientColor に改名して、現状の GradientColor を MultiDimensionalGradientColor とかにする手もあるけど、
                 しかしこのアプリ内ではグラデをほぼ常に後者の（1Dも後者で包んだ）形で使うので、そっちを一番主役っぽい名前、つまり GradientColor にしたい。

              \* GradientColor 内の AxisGradientColor（の改名物）のセットに対して、どこかで空間軸をそれぞれ対応付ける必要があるけど、
                 それは「 空間軸[0]が AxisGradientColor[0] に対応し、[1] が [1] に対応し… 」みたいな関係にする必用が生じてしまう。
                 わざわざ分離して、外の階層でそんな順序対応を考えるくらいなら、明らかに元の構造に入れてしまった方がシンプルで実利もある。

              で、結局現状通り1Dグラデを AxisGradientColor と命名して、それに空間軸を持たせたらストンと解決する。

              多軸グラデの設定UIを考えた時に、例えば「グラデ1」画面の中で「軸1」「軸2」みたいなタブがあって、それぞれのタブで1Dグラデを作って空間軸も選ぶ、
              みたいな形は普通にユーザビリティが高そう。つまりユーザー視点での直感もあまり外してない。
              やはりグラデの向きに空間軸を対応付けるのは、直感的には合ってる気がする。
              あまり「概念として分離可能」とか哲学的に事を考えすぎるのはたぶんよくない。
              普通のユーザーはわざわざ概念としての分離を試みない。
              「グラデの向きどこで設定すんの？」って考えたらグラデの設定見るでしょ。2軸なら各軸それぞれの設定に向き指定（X/Y/Z）ある事を期待して見るでしょ。
              それでいいんだよ。いいんだよそれで。

          * 結局、 この GradientColor はあくまでも「グラフソフトのグラデ彩色設定のための設定コンテナ」なのであって、
            「本質的にグラデとは何か」みたいな贅肉を削ぎ落した概念形状は誰得なのって話でもある。
            そして「グラフソフトのグラデ彩色設定のための設定コンテナ」として見れば、むしろグラフのグラデ彩色の時に頭に浮かぶものが紐づいてて自然ですらある。
            「このグラデをかける際に、どの系列とどの系列に適用するか指定するのは？」→ グラデの設定に系列フィルタがあります、っのは至極自然で。もうええやんそれで。

            -> 確かに。しかしそれなら、GradientColor というよりも GradientColorConfiguration 的な何かであってほしいような。

               -> ああ、それは一利あるが、そうするとその中でグラデの色概念を定義した GradientColor が欲しくなり、
                  突き詰めると結局「 GradientColor を包む設定コンテナを一層挟む的な 」話になって、まさに19行目の案になる。
                  堂々巡りでそこまで戻ってしまった。

                  * その違和感は結局は「GradientColor」という名前なのにグラデの色だけでなく適用時の設定まで包んでるからだよな。
                    だから GradientColor の命名なんだよ要は。
                    こいつが持ってるべきかどうかじゃなく、たぶん持ってないと構造的に無理が出る（分離すると大がかりになりすぎる）んだけど、
                    そんなら GradientColor っいう削ぎ落し過ぎた命名でいいの？っていう。たぶんそういう問題かも。

                  -> まぁ命名や1層ラップの話なら後でどうにでもなるので、「持ってる」事自体が大して問題にならんのなら、
                     もうとりあえず現状 GradientColor のまま系列フィルタ持たせて実装して先に進もうよ。とりあえず。
                     気にならんかったらそのまま、気になったら後で改名すればいいんだし。
