# やる事リスト

※ 自戒: あまり枝葉の設計で肩肘張り過ぎて実装が鈍らないように。まだゴールは果てしなく遠いので、とにかく何かしら書き進める。取っつきやすそうなタスクをここに切り出しつつ。

## データファイルを開くフローの仮組み

* データ系列の内部表現の確認
* ファイル由来データ系列の内部表現の検討（確か既に作ってたはず: ArrayDataSeriesとか）
* 仮の即席実装として、とりあえず3列ファイルとかから上記を生成するデコーダ書く
* メニューバーに暫定的な「データファイルを開く」とかのメニューを増設し、上記処理と繋いで開けるようにする
* 以上で、データファイルを開くフローの（仮の）骨組みが一応できるので、そこで俯瞰して細部を再検討して直したり次を考える

### 脳内議論

↓ 実装した。様子見が済んだら以下は消す

* データI/O周りを書く上で、複数の DataSeries をまとめる DataSeriesGroup みたいなコンテナが欲しいかも。要は大系列の構造。一つのデータファイルに複数系列が存在し得るので、そういう単位のコンテナとしてほしい。

    ↑ List\<AbstractDataSeries\> に対する優位性は？ 結局要素と count 持たせるだけになる気が。

    ↑ データ群をファイル群に紐づけて管理する場面は多分そこそこ生じるが、上記の構造が無いと List\<List\<AbstractDataSeries\>\> とかになってしまって、コメントで説明してもコードがややこしすぎる。「トップ階層がファイルのリスト、その次の階層が各ファイル内のデータ系列のリストで…」とか。上記構造があれば List\<DataSeriesGroup\> fileDataList とかでストンと収まる。

    ↑ ならついでに系列名の保持とか対応付けとかも行うのもありか。→ いや系列名はむしろ個々の AbstractDataSeries が持ってるべきかと。

* 例外どうする？ I/Oで新しいの要るかも。まだ独自例外は作ってなかった。IOException を使ってもいいけど、データファイルの書式エラーとかは別種の例外が欲しい気もする。

    ↑ API の openDataFile とかは IOException を投げる仕様になっていて、互換考えるとそこで検査例外は増やせないので、どうせAPI表層では IOException でラップして rethrow する形になる。なので、内部処理のためだけに新種例外がほんとに欲しいか？ という話になる。どうだろ

    ↑ 内部処理で、ファイルアクセスに失敗したのか内容が違ったのかでハンドリングを分ける必要は明らかにあるので、それを区別する上であった方が分岐をすっきりした形に書ける。

* 上記例外、作るなら例外用のパッケージにまとめる？ それとも model 内のそれぞれの場所に作る？

    ↑ model外から参照したい場合もあり得るので、model外の独立パッケージにあると後々で詰まずには済む。model 内定義だと、なにかの拍子に view 側で拾ってチェックしないといけない場面が（無いのがベストだけど）もし生じた時に疎結合を破る事が避けられない。

    ↑ しかし普通は例外だけパッケージにまとめるってのは変で、それ使うパッケージに属してるのが多いような。APIで投げるならともかく、先の議論の帰結として内部処理用にするならなおさら。

    → むしろ独立パッケージって config パッケージみたいにAPIから使う用を兼ねてるみたいな雰囲気が出てしまうような。このソフトだと。

    → まあ内部専用なら互換気にせずに後でどうとでもできるんだし、とりあえず model 内に、その例外をメインで使うサブパッケージ内のその場で作っておけばいいかと。ととりあえず。やってみて微妙ならその時まとめるとか。


↓ 実装した。様子見が済んだら以下は消す

* データファイル書式の自動推定、Ver.5.6 → 6 でリフレッシュしたいけどアルゴリズムどうする？ デリミタ判定 → 列数とか空行構造から書式判定、の流れだけど、まずデリミタ判定をどうするか。

    * 5.6 のデリミタ判定は確かCSVとSTSVの両方で仮に部分パースしてみて列数が多い方を取ったりしてたような。無駄に処理コスト高い気がするけどなんでそうしたんだっけ。

    * とりあえずはデリミタ判定は、空行＆コメント行以外が全てカンマを含んでたらCSV、そうでなければSTSV、の二択か。これはすぐ思いつくが果たしてどうだろ。

    * strict な TSV とかサポートした時にSTSVとTSVの区別が付きやすい方式の方がいいかも。

        ↑ そんなら左側3列が常に数値である事を用いて (数値)(デリミタ)(数値)(デリミタ)(数値) って並んでるはずだから、そっからデリミタを抜き出す？ 最初の有効行とか仮読みして。

        ↑ しかし数値が浮動小数点数だからストレートで正規表現マッチするのはコスト的にもエグさ的にもなんか嫌だからな。あり得る全てのデリミタで split してみて間が数値かどうかを見るか。逆に。

        → CSVでも strict TSV でも判定いけるし、STSVも「TSVと見なして切ってみた時に空白混じってたらSTSV」という判断でいける。結構シンプルでよさげかと。

        ↑ なんかそれだと結局 5.6 に近い。そういう事だったのか。

    * 上記をもうちょっとひねって、「カンマで切ってみて左列にタブか空白が混じってなければCSV、混じってればCSVではない」→「CSVじゃなかった場合、タブで切ってみて左列に空白が混じってなければTSV、混じってればSTSV」みたいにいけるのでは？ カラム値が必ず数値である事を利用してはいるが、数値判定自体は行わずに軽い空白混入判定のみでいける。 → これを実装した

