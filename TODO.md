# やる事リスト

※ 自戒: あまり枝葉の設計で肩肘張り過ぎて実装が鈍らないように。まだゴールは果てしなく遠いので、とにかく何かしら書き進める。取っつきやすそうなタスクをここに切り出しつつ。


## 描画関連を最低限実用できるあたりまで充実させる

* 済: カラーバーを描く
* 凡例を描く。これは 5.x にはないので色々と考察検討が要るかも
* アニメーションとかだと系列数が膨大になるので、凡例としてどういう形が適切か？ を考える。少なくともそれを考慮すると、凡例は「大系列ごと」か「小系列ごと」かのモード切り替えが必要になりそう。
* 上記に付随して、場合によっては系列の階層を増やす必要があるかも。DataSeriesGroup はファイル1個や z(x,y,t) 数式1個に対応するので(contains multiple DataSeries)、それをさらに包む構造が… しかし名前がややこしいなそれたぶん。

## 数式関連を最低限実用できるあたりまで充実させる

* 済: 各数式のプロット画面、新規プロットだけでなく更新を可能にする。UIどうすべきか考える必用がある。
  (現状はそのあたり考えるのが面倒なので「OK」押したら消えて、また開いたら追加、みたいな挙動にしてる)
  -> 起動時は「PLOT/プロット」ボタンにして、その後「UPDATE/更新」みたいに変化する感じでいいのでは？ んで ↓ の編集時は起動時点から後者モードにする。
* 済: 既存数式を選択して編集できる仕組みを実装する。「ファイルを開く」UIのような画面か、それともメニュー項目からの単純なセレクトボックス表示か。どっちがいいかな。
  -> 「ファイルを開く」UIはファイルパス列をコピペしたい場合を想定してあの形にしてるけど、数式は離散化数とか範囲とかの項目もあるので数式だけでは決まらないし、あのUIにしてもあんまりメリットないような。テキストエリアじゃなく「リストUIをクリックして編集画面を開く」みたいな挙動にするの必須だし、その方向の独立ウィンドウの完成系はむしろセレクトボックスのダイアログそのものでは。
* 「x(t),y(t),z(t)」形式の実装について考える。変数 t をアニメーションモードとどう整合させるべきか。もしくは t を避けて s や i にするか。-> i は将来的に複素サポートした時にややこしいので n か。-> いやしかしここでの t は整数じゃなく実数でしょ。i や n はまずい。線素の累積だし普通に s でいいんじゃないの。どうせこんなんプロットすんの理工系の人だし線積分やってるでしょ。伝わるって。むしろ t よりも。t は微分方程式くさいし s の方がむしろベストな気もするし。 -> いや線素の累積値ちゃうで。線の周辺なぞる長さのディメンションには対応してないやろ。依存してるだけや。まさに動きにおける t 的な量や。属するディメンションが全然ちゃう。 -> ああ確かに、どうすっかな -> アニメーションのTRACEモードは座標点 i を t = i * Δt where Δt = timeRange/N と見なしてアニメーションするモードやし、プロット画面で「アニメーション」を選んだらアニメーション画面をTRACEモードで開いてΔtの値を通知セットすれば何も問題なにのでは？ どこも概念的な不整合はない。TRACEモードの想定概念そのもの。 -> 確かに。じゃあ問題は z(x,y,t) の方か。-> z(x,y,t) も「系列を時系列と見なしてプロット」の想定概念そのもので、Δtを適切に通知転送すれば何も問題がない。-> 要は両者でアニメーションモードが違うというだけで、同時に両立はしないけども、アニメーションモードと概念矛盾はしない。z(x,y,t) と x(t),t(t),z(t) を同時に同じ t でアニメーションさせられないというだけ。それはちょうど、異なるアニメーションモードを想定したデータファイルを、同時にアニメーションさせられないのと同じ原因で、数式自体の問題ではない。アニメーションモード側でそういう仕組み（複数モードのシンクロナイザみたいなもん）を作るかどうかの問題。 -> 確かに。じゃあここではとりあえず安心して Ver.5.6 と同等の処理をするツールをそのまま組み込みで実装すればいいだけか。あとの改善や割り切りはアニメーションツール実装時の管轄で、今ここの実装の段階で悩む必用はない。素直に Ver.5.6 の正常進化形でやればいい。安心納得。
* 同様に「z(x,y,t)」についても考える必要がある。上記と同時に考えるべき。-> 考察は着地した（上記参照）。素直に複数系列のメッシュを生成すればいい。-> 凡例がどえらい事にならん？ -> ああ… なんか特例が要るかな。 -> いや、凡例はファイルごとに付くし、ファイルは複数系列を含み得るので、大系列ごとに付けられるようにすればいい。そういう仕様にすれば、z(x,y,t) は t ごとに異なる系列を含む大系列が1つなので、凡例はすっきり書ける。凡例のオプションで「大系列ごと」か「小系列ごと」を選べるようにすればいい。 -> つまりこれも凡例の実装側で悩む管轄の話で、この数式ツール実装の時点で悩む必要はない。
* 数式は設定ファイルで保存できてもいい。ファイルパスとは違って外部に依存せずソフト内で閉じてる情報だし、特定の数式を色んなファイルに重ねて表示したいような解析シーンはよくあるし。将来的に。

## 全て済み: ファイルメニューを最低限実用できるあたりまで充実させる

* 済: 「ファイルを開く」のメニューのUI、とりあえず 5.x ほぼそのままで実装（ここは特に不満ないし）
* 済: 「画像のコピー」メニューの実装
* 済: 「画像の保存」メニューの仮実装
* 済: 「画像の保存」メニューの本画面＆イベント実装
* 済: スプレッドシートからのデータの貼り付けメニューの仮実装
* 済: スプレッドシートからのデータの貼り付けメニューの本画面＆イベント実装
* 済: 上記で、各テキスト関連UIでのコピペメニューをどの方向で実装するかの検討も済ませる。そしてそれを他のテキストUIにも適用。

## 全て済み: データファイルを開くフローの仮組み

* 済: データ系列の内部表現の確認
* 済: ファイル由来データ系列の内部表現の検討（確か既に作ってたはず: ArrayDataSeriesとか）
* 済: 仮の即席実装として、とりあえず3列ファイルとかから上記を生成するデコーダ書く
* 済: openDataFile 系のAPIを実装し、コードからファイルを渡して読ませてプロットしてみる
* 済: データを保持・管理するデータストア的なオブジェクトを作って、Model直下のデータ系列をそれを介するようにする。
* 済: 範囲の自動調整が ON の場合に、自動で範囲を検出して合わせる処理を実装する
* 済: メニューバーに暫定的な「データファイルを開く」とかのメニューを増設し、そちらからでも開いてプロットできるようにする（まだUIは凝らない）
* 済: このあたりでマトリックス書式のデコーダも実装してしまいたい。そうすればとりあえずは何かに使えるようにはなるので。Ver.3.x 世代相当くらいにはなる。細かい枝葉で全て5.x以上をいきなり目指すより、まず何かに使える状態に着地させてから拡張していったほうが多分いい。

* 以上で、データファイルを開くフローの（仮の）骨組みが一応できるので、そこで俯瞰して細部を再検討して直したり次を考える


### 脳内議論

↓ 実装した。様子見が済んだら以下は消す

* データI/O周りを書く上で、複数の DataSeries をまとめる DataSeriesGroup みたいなコンテナが欲しいかも。要は大系列の構造。一つのデータファイルに複数系列が存在し得るので、そういう単位のコンテナとしてほしい。

    ↑ List\<AbstractDataSeries\> に対する優位性は？ 結局要素と count 持たせるだけになる気が。

    ↑ データ群をファイル群に紐づけて管理する場面は多分そこそこ生じるが、上記の構造が無いと List\<List\<AbstractDataSeries\>\> とかになってしまって、コメントで説明してもコードがややこしすぎる。「トップ階層がファイルのリスト、その次の階層が各ファイル内のデータ系列のリストで…」とか。上記構造があれば List\<DataSeriesGroup\> fileDataList とかでストンと収まる。

    ↑ ならついでに系列名の保持とか対応付けとかも行うのもありか。→ いや系列名はむしろ個々の AbstractDataSeries が持ってるべきかと。

* 例外どうする？ I/Oで新しいの要るかも。まだ独自例外は作ってなかった。IOException を使ってもいいけど、データファイルの書式エラーとかは別種の例外が欲しい気もする。

    ↑ API の openDataFile とかは IOException を投げる仕様になっていて、互換考えるとそこで検査例外は増やせないので、どうせAPI表層では IOException でラップして rethrow する形になる。なので、内部処理のためだけに新種例外がほんとに欲しいか？ という話になる。どうだろ

    ↑ 内部処理で、ファイルアクセスに失敗したのか内容が違ったのかでハンドリングを分ける必要は明らかにあるので、それを区別する上であった方が分岐をすっきりした形に書ける。

* 上記例外、作るなら例外用のパッケージにまとめる？ それとも model 内のそれぞれの場所に作る？

    ↑ model外から参照したい場合もあり得るので、model外の独立パッケージにあると後々で詰まずには済む。model 内定義だと、なにかの拍子に view 側で拾ってチェックしないといけない場面が（無いのがベストだけど）もし生じた時に疎結合を破る事が避けられない。

    ↑ しかし普通は例外だけパッケージにまとめるってのは変で、それ使うパッケージに属してるのが多いような。APIで投げるならともかく、先の議論の帰結として内部処理用にするならなおさら。

    → むしろ独立パッケージって config パッケージみたいにAPIから使う用を兼ねてるみたいな雰囲気が出てしまうような。このソフトだと。

    → まあ内部専用なら互換気にせずに後でどうとでもできるんだし、とりあえず model 内に、その例外をメインで使うサブパッケージ内のその場で作っておけばいいかと。ととりあえず。やってみて微妙ならその時まとめるとか。

* Config 系の validate で検査不合格になった時の例外、現状は IllegalStateException とか投げてるけど、そこは RinearnGraph3DConfigurationException とかあってもいいかもしれない。実質 configure API呼ぶ時に catch しなきゃいけないし、IllegalStateException はワイドすぎるような。config は正しいけど読む側がぶっ壊れてるのと区別つかん。


↓ 実装した。様子見が済んだら以下は消す

* データファイル書式の自動推定、Ver.5.6 → 6 でリフレッシュしたいけどアルゴリズムどうする？ デリミタ判定 → 列数とか空行構造から書式判定、の流れだけど、まずデリミタ判定をどうするか。

    * 5.6 のデリミタ判定は確かCSVとSTSVの両方で仮に部分パースしてみて列数が多い方を取ったりしてたような。無駄に処理コスト高い気がするけどなんでそうしたんだっけ。

    * とりあえずはデリミタ判定は、空行＆コメント行以外が全てカンマを含んでたらCSV、そうでなければSTSV、の二択か。これはすぐ思いつくが果たしてどうだろ。

    * strict な TSV とかサポートした時にSTSVとTSVの区別が付きやすい方式の方がいいかも。

        ↑ そんなら左側3列が常に数値である事を用いて (数値)(デリミタ)(数値)(デリミタ)(数値) って並んでるはずだから、そっからデリミタを抜き出す？ 最初の有効行とか仮読みして。

        ↑ しかし数値が浮動小数点数だからストレートで正規表現マッチするのはコスト的にもエグさ的にもなんか嫌だからな。あり得る全てのデリミタで split してみて間が数値かどうかを見るか。逆に。

        → CSVでも strict TSV でも判定いけるし、STSVも「TSVと見なして切ってみた時に空白混じってたらSTSV」という判断でいける。結構シンプルでよさげかと。

        ↑ なんかそれだと結局 5.6 に近い。そういう事だったのか。

    * 上記をもうちょっとひねって、「カンマで切ってみて左列にタブか空白が混じってなければCSV、混じってればCSVではない」→「CSVじゃなかった場合、タブで切ってみて左列に空白が混じってなければTSV、混じってればSTSV」みたいにいけるのでは？ カラム値が必ず数値である事を利用してはいるが、数値判定自体は行わずに軽い空白混入判定のみでいける。 → これを実装した



↓ 実装した。様子見が済んだら以下は消す

## リファクタ: ArrayDataSeries[] 配列を引数にとってる箇所を DataSeriesGroup を使うようにする

* Model層とかである。setArrayDataSeries(ArrayDataSeries[] allArrayDataSeries) とか。やっぱ Series が複数形でも同一語なのが少しややこしいし、今は別の事情で DataSeriesGroup というコンテナができたので、もう配列じゃやなくそっちに詰めたほうがわかりやすい。

    ↑ しかし、DataSeriesGroup は abstract class な DataSeries を要素に持つので、型が少しゆるい。上記は Math プロット系じゃなくデータ配列やファイル由来の ArrayDataSeries をまとめたいので、DataSeriesGroup に詰めてしまうと要素参照で毎回型検査が要る。

    ↑ なら DataSeriesGroup をジェネリックな型にするか？ → 明らかにそうした方がいいような。abstract で詰めたきゃ <DataSeries> して、Arrayに限定したけりゃ <ArrayDataSeries> にすりゃ済む話だし、たぶんやって得しかない。→ とりあえず上記の通りジェネリックにした


↓ 実装した。様子見が済んだら以下は消す

## データストアの実装

現状は Model 直下に各データ系列が保持されているが、データストア的なオブジェクトを作ってそれに保持・管理させた方がよさそう。なぜなら：

* 現状だと、データ系列の setter / adder / getter 類が Model に直接生えまくって見通しが煩雑
* 同上、範囲の自動検出とかのメソッドも Model に生えていく事になるし、その処理を Model 直下に実装するのがそもそも微妙
* かといってデータ系列を public final 化すると、add の時に関連更新処理をフックとかを（将来的にやりたくなっても）できないので、検討はしたけどやっぱNG判断になった
* 他にも、後々でデータ変換機能（対数軸とか、式での変換とか）を実装した時に、登録されているデータ系列から一枚変換層を噛ませて使う必要がどうせ生じそう。それをデータストア的なものの内側で包んで行ってしまえば、外から参照する際は気にしなくていいので、実装時もメンテ時も楽

以上を俯瞰するとどこかのタイミングで必須に思える。ので、範囲の自動検出を実装してるいま行ってしまった方がいい


↓ 実装した。様子見が済んだら以下は消す

## リファクタ: DataSeriesGroup を Iterable 対応する

拡張for文で使う時に getDataSeriesList() してるけど、これの登場頻度が多くて煩雑なので（思った以上にグループ要素をループする機会が多い）、DataSeriesGroup 自体を Iterable 対応してしまった方がいい。初見での可読性は落ちるかもしれないけれど、いちいちList引っ張りまくるよりはマシかと。


