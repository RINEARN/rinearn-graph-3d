# やる事リスト

※ 自戒: あまり枝葉の設計で肩肘張り過ぎて実装が鈍らないように。まだゴールは果てしなく遠いので、とにかく何かしら書き進める。取っつきやすそうなタスクをここに切り出しつつ。

## 気付いた事（対応が必用な事）

* 厚みをフラットにしたらグリッド線と surface が重なる。グリッド線のZ方向の優先度オフセットを少し調整すべき。

* 済: プロット処理、現状は以下の流れでやってるけど（無関係なものは省いてる）、Z(x,y) のX-Y範囲に関して問題がある。

		this.updateMathDataSeriesCoordinates();
		this.adjustRanges();
    (あとは各 plotters でデータプロット)

  具体的な話。
  まず updateMathDataSeriesCoordinates を最初にやる事自体はいい。なぜなら、それで Z(x,y) のZ範囲や、x(t),y(t),z(t) のXYZ範囲が決まるので。
  で、その後に adjustRange するのも自然。

  が、ここで Z(x,y) はもともと X-Y 定義域を持っていない（可変）である事から、adjustRange で X-Y 範囲が変わると、
  最初の updateMathDataSeriesCoordinates で生成されたメッシュが描画範囲外にずれ込む。

  具体的には、Z(x,y)単体でプロットしている場合は問題ないけど、他のデータや数式と一緒にプロットしてると、そっち基準で range が adjust されるので必ずずれる。
  なので Z(x,y) の再計算が必用で、さらにそれによってZ範囲もまたずれる可能性がる。

  シンプルに、しかし確実に正しく範囲設定＆メッシュ生成できるフローを探す必要がある。
  
  -> X/Y方向に有界な数式＆データと、非有界な数式とを同列で扱ってる事が本質的問題だったので、以下のようなフローに変えて解決した:
  
		// Update coordinate values of XY-bounded math data series, e.g.: x(t),y(t),z(t).
		// This type of expressions have their own ranges for all the X, Y, and Z axes.
		this.updateXYBoundedMathDataSeriesCoordinates();

		// Adjust the X and Y ranges to fit to the currently registered data.
		this.adjustXYRanges();

		// Update coordinate values of XY-unbounded math data series, e.g.: z(x,y).
		// This type of expressions can have Z Z ranges under the given X/Y ranges, but don't have their own X/Y ranges.
		this.updateXYUnboundedMathDataSeriesCoordinates();

		// Adjust the Z and gradient color ranges to fit to the currently registered data.
		this.adjustZRange();
		this.adjustGradientColorRanges();


* 済: Renderer に backgroundLayer/foregroundLayer 実装したけど、スクリーンリサイズ時に内容がリセットされるので、内容の再描画が必要。これはAPI仕様としてはそうしていい。
  一方、グラフソフトとしては画面リサイズ時にカラーバーとか凡例とかを再描画しなきゃいけないので、レンダリングループ内でリサイズ時にそれらを再描画して各層を自動合成する必用がある。
  が、もしAPIユーザーがカラーバーとか凡例とかを描きたくない場合には、clear() でせっかく全部消したのに、グラフ画面のリサイズ時に復活してしまう。
  この、GUIとAPIでのユーザビリティの衝突をどう着地させるか。

  -> リサイズ時に背景/前景の内容が飛ばないようにすれば解決なので、まずその線の可否を検討すべきだが… 無理だろなあ。

     -> 現実的に無理筋。仮にカラーバーと凡例に関してめっちゃ工夫して実現できたとしても、ユーザーが Graphics2D を使って自由に描く内容は、
        例えばサイズ縮小で一旦領域削れてから拡大で戻ったりすると、どうあがいても復元できない。無限のバッファが無いと原理的に無理。
        それを不完全にやるくらいなら、リサイズで内容飛ぶからもう一回描いてねって仕様の方がよっぽどわかりやすい。

  * なら、「カラーバーや凡例などの2D描画コンテンツを、リサイズ時やrender時などに自動で描くかどうか」のモードを用意する？

    -> 3D と 2D で扱いが非対称になるのが微妙だが… もしかすると、現実解はそれしかないかもしれん。もうちょっとよく探す必要はあるが。

    -> そもそもカラーバーや凡例は登録挙動にした。よく考えたら他の3D描画系も登録挙動だし。なので3D/2Dの扱いはむしろ対称性がよくなる。

* LightConfig の中の ambientReflectionStrength の Strength ってなんか微妙かも。要再検討

* 済: matrixexam.csv を曲面プロットしてる時、画面左の軸長さスライダーを操作して各軸長めにすると、角度によって面のセルが黒色（#000000）になる。
  光学計算かなんかののバグか？ デフォルトの長さでは起こらないので、変換行列の対角成分を書き換えた事に対して光学計算が対処できていない可能性がありそう。

  * メッシュ、点、線では問題ないので、その事と角度依存な事からすると、明らかに光学周りだ。たぶん。
  -> 軸を伸ばしたからポリゴンが光源より外側に出てんじゃね？ 点光源だったっけ？ 並行光源だった気がするけど意外と点だったか？

  -> 法線ベクトルの長さが、従来だと変換で不変だったのが、変換行列に軸長変化成分を入れた結果として、1 に保たれなくなったのが原因だった。
     なので再規格化を入れたら直った。

* 済: RinearnGraph3DRenderer のメソッド命名、drawGrid とか drawLabel とかの命名が変。あと凡例もできたので、Label という語はもはや曖昧で、drawAxisLabels とかに改名が要る。
  互換サポートはinterface のデフォルトメソッドでデメリットなくできるし、6.0 のタイミングで直しておく＆拡張しておくべき。

  -> 済: 作ったけど、drawLegendLabels とか drawColorBar とかも追加して、でもそれらは3Dではなく2D描画なので、現状 render 時に自動で描かれてしまうので、なんか制御変える必要がある。

     -> foregroundImage に描き込むようにして render 時は重ねるだけという挙動にする。
        んで、凡例やカラーバーの描画は現状 render 任せだけど、上階層からも replot 時に明示的に呼ぶようなフローに変更する。
        描画エンジンAPIの定義と使い方としては、明らかにそうしたほうが筋がいい。
        APIメソッドのために変な分岐を入れるよりは、そう使用フロー自体も変えて、上層からAPIとして真っ当な使い方をすべき。

        -> 上記方針自体は基本的には問題ないんだけど、呼んだ瞬間に前景層に2D的に描くような処理にしてしまうと、グラフ画面がリサイズされた時に前景バッファがクリアされるので、リサイズ検知して2D的なもののみ再描画する必用が生じてしまう。つまり draw 系メソッドの中で、3D系と2D系で扱いが非対称になる。

           -> 済: drawColorBar とかを呼んだ時点ですぐ描画されるのではなく、「描画登録を行う」という仕様にして、render 時に描かれるようにした。
              この挙動自体は他の draw 系と統一性のある仕様だし、むしろこうあるべきという形に結果的に落ち着いた。

* 済: Z軸の長さをゼロにしても陰影が残る。たぶん法線の計算がおかしい。
  完全にゼロにしなくても、浅いアスペクト比にしたら陰影や光沢がきつすぎる。
  そういえば、法線を定義した後に axisLengthFactor 入りの変換行列をかけてたけど、変換した後で法線求めないとだめなのでは？

  -> 確かに。というかそもそも法線ベクトルを同じ変換行列で処理しちゃダメだ。空間の引き延ばしをイメージすると、明らかに向きがおかしくなる。
     ある面を一方向に引き延ばした時に、その法線ベクトルは、同じ引き延ばしでは処理できない。補正を入れるか、変換後に法線を求める必用がある。後者は重いが一番確実か。

     -> 空間長さが変化した時点で、法線ベクトルを計算しなおす処理を入れた。しかしそれでも、変換行列を座標用と方向用で分ける必要があった。つまり両方必用だった。
        前者のみで済まない理由は、例えばZ次元をゼロにしてフラット化した時に、形としての法線ベクトルはZ方向の真上を向くが、
        しかしそこに通常の座標変換行列をかけてしまうと、Z次元長が0なので結局法線ベクトルは (0,0,0) になってしまう。
        なので対角スケーリング成分は 1 のままで、視点に応じた方向回転だけ行う行列が別途必要だった。そういえばそうだった。こういう非等方空間な事やる時って。

* ColorBar の描画の有無や位置などを指定するための config が将来絶対に要りそう。現状だと「グラデのON/OFFにシンクロして規定の位置に描く」だけなので存在しない。
  しかし早めに作っておかないと、将来的に互換が崩れる可能性がある。

  -> 作る際に、ColorBarVisibilityMode { AUTO, ALWAYS_VISIBLE, ALWAYS_INVISIBLE } みたいにすれば別に互換問題は生じない。デフォルトがAUTOにすれば。
     で、APIユーザー側がグラデのON/OFFに対応させて ColorBarConfig? のON/OFF を手動で切り替えるのは面倒すぎるし不親切なので、
     ここは可視性フラグではなく必ず enum にしてデフォルトAUTOにすべき。

     という事で今は保留にして、必用な時に作れる。
     なぜ保留にするかというと、config.colorbar パッケージは冗長だし、「補足情報の設定」みたいな管轄を作ったほうがよさそうなので。
     そのコンテナのいい概念管轄＆命名が浮かんだ時に実装する。

## メニューの実装を進める

* 済: 軸反転とか対数軸とかのオプション。これは ScaleConfig を書き換える。ScaleSpaceConfig みたいなんが新規で要る？
  -> データ変換を後で入れ込むなら、それを踏まえた config 管轄を作った方がいいかも。対数プロットもまあデータ変換の一種っちゃあ一種っぽいので。

     -> 軸反転は違うのでは？
        -> 確かに軸反転はどっちかというと描画側の事情。しかし対数軸との親戚な概念の気もする。概念境界意外とややこしいな。

     * 恐らく目盛り設定の管轄でもないからなあ軸反転は。まさに空間設定だ。
       -> いや普通に目盛り管轄じゃないの？ 目盛り管轄に対数プロットと軸反転あってもなんら変じゃない気がするが。

       * 確かに。データ変換という目線で見ると目盛りじゃないが、目盛りという目線で見ると目盛りだ。データ変換を別枠にするならまあアリか。

         * そもそもデータ変換しても目盛りは変わらないが、対数軸は目盛りが変わるし、質的に対数軸は普通のデータ変換より上位層での存在でしょ。
           まず対数軸の目盛りが振られた空間（またはリアルスケール空間）というものがあって、そこにデータ変換したデータをプロットする。
           なので、データ変化の config 管轄に対数軸を入れ込む事にこだわる妥当性はよく考えたらそんなになさそう。

           で、空間設定っていう config をわざわざ作るくらいなら、
           AxisScaleConfig 内に isLogScaleEnabled と isReversed とかがあればそれで十分で、直感的にもわかりやすい気がする。
           だってそもそも普通に言葉として「log scale / 対数目盛り」ってみんな言ってんだし。

           -> たぶん空間設定っていう概念は、軸反転と対数軸を一緒にペアにして考えた結果として浮かぶイメージだと思う。
              対数軸が scale config でいいなら、残りは軸反転が scale config に居ていいか？ って話になる。

              -> まあ log scale が許されるなら軸反転が許されない気はないと思う。軸反転の方が対数軸よりもっと低抽象度な空間変換なので。

                 で、GUI で「空間」タブができる感じかな。オプションのみにしてもいいけど、目盛り設定にもシンクロページがあってもいい。必須じゃないので後でいいけど。

  * 上記の結果からして AxisScaleConfig に入れ込むとして、実装はどうする？
    -> Renderer 内の rotationMatrix の右に、単位行列の各成分の符号反転させたやつをかければいい。たぶんそれが一番シンプル
       * 各成分の絶対値を変える事で、軸長の変化も一緒に実装できる。やっとグラフ左のバーの操作に対応できるか。

         * 上記がよさそう。とりあえずこの方向性で実装を進める。

* 済: 画面再度の次元長スライダー

* 等高線オプション。これは現状とりあえず 5.x のコードからそのまま移植でいい。あれ掃除するのはたぶん大変で、コーナーケースがたくさんあるから用意周到にやらなきゃだし。現状ちゃんと動いてるし、閉じてる処理だから中をいじる機会もほぼ無いし、なのでとりあえずそのままで。中をいじる機会がある時にまた検討する。

* 済: EqualDivisionTicker の dividedSectionCount って冗長かも。単に sectionCount でいいのでは。上記の等高線の config コンテナを設計する際に意識したが、そっちは単に sectionCount にした。-> 再考して、両方とも divisionCount にした。等高線も EQUAL_DIVISION モードとかできるかもしれないし、客観的にも divisionCount が分割の数として一番っぽいので。

* 済: RangeConfig の setMinimum/setMaximum も Coordinates を付けたい

## API系の5.x互換レベル到達を急ぐ

* GUI含む全機能の完成にはまだ距離があるが、APIだけでも5.x互換なレベルにもっていけたら、とりあえずグラフ描画ライブラリとしての用途はカバーできる。そっち方面の展開は正式リリース前でも進められる。ので効果としてでかい。優先的に急いで推進すべき。
* 描画エンジンの文字列書くAPI。エンジンを組み込みに使ってるユーザー層が（少ないが）存在はしているので、とりあえず描画エンジンAPIだけでもオープンソースで全用途カバーしたい。そしたら簡易3D描画ウィンドウとしてはとりあえず使えるようになる。

## 描画関連を最低限実用できるあたりまで充実させる

* アニメーションとかだと系列数が膨大になるので、凡例としてどういう形が適切か？ を考える。少なくともそれを考慮すると、凡例は「大系列ごと」か「小系列ごと」かのモード切り替えが必要になりそう。
* 上記に付随して、場合によっては系列の階層を増やす必要があるかも。DataSeriesGroup はファイル1個や z(x,y,t) 数式1個に対応するので(contains multiple DataSeries)、それをさらに包む構造が… しかし名前がややこしいなそれたぶん。

## 数式関連を最低限実用できるあたりまで充実させる

* 済（実装も）: 「x(t),y(t),z(t)」形式の実装について考える。変数 t をアニメーションモードとどう整合させるべきか。もしくは t を避けて s や i にするか。-> i は将来的に複素サポートした時にややこしいので n か。-> いやしかしここでの t は整数じゃなく実数でしょ。i や n はまずい。線素の累積だし普通に s でいいんじゃないの。どうせこんなんプロットすんの理工系の人だし線積分やってるでしょ。伝わるって。むしろ t よりも。t は微分方程式くさいし s の方がむしろベストな気もするし。 -> いや線素の累積値ちゃうで。線の周辺なぞる長さのディメンションには対応してないやろ。依存してるだけや。まさに動きにおける t 的な量や。属するディメンションが全然ちゃう。 -> ああ確かに、どうすっかな -> アニメーションのTRACEモードは座標点 i を t = i * Δt where Δt = timeRange/N と見なしてアニメーションするモードやし、プロット画面で「アニメーション」を選んだらアニメーション画面をTRACEモードで開いてΔtの値を通知セットすれば何も問題なにのでは？ どこも概念的な不整合はない。TRACEモードの想定概念そのもの。 -> 確かに。じゃあ問題は z(x,y,t) の方か。-> z(x,y,t) も「系列を時系列と見なしてプロット」の想定概念そのもので、Δtを適切に通知転送すれば何も問題がない。-> 要は両者でアニメーションモードが違うというだけで、同時に両立はしないけども、アニメーションモードと概念矛盾はしない。z(x,y,t) と x(t),t(t),z(t) を同時に同じ t でアニメーションさせられないというだけ。それはちょうど、異なるアニメーションモードを想定したデータファイルを、同時にアニメーションさせられないのと同じ原因で、数式自体の問題ではない。アニメーションモード側でそういう仕組み（複数モードのシンクロナイザみたいなもん）を作るかどうかの問題。 -> 確かに。じゃあここではとりあえず安心して Ver.5.6 と同等の処理をするツールをそのまま組み込みで実装すればいいだけか。あとの改善や割り切りはアニメーションツール実装時の管轄で、今ここの実装の段階で悩む必用はない。素直に Ver.5.6 の正常進化形でやればいい。安心納得。
* 同様に「z(x,y,t)」についても考える必要がある。上記と同時に考えるべき。-> 考察は着地した（上記参照）。素直に複数系列のメッシュを生成すればいい。-> 凡例がどえらい事にならん？ -> ああ… なんか特例が要るかな。 -> いや、凡例はファイルごとに付くし、ファイルは複数系列を含み得るので、大系列ごとに付けられるようにすればいい。そういう仕様にすれば、z(x,y,t) は t ごとに異なる系列を含む大系列が1つなので、凡例はすっきり書ける。凡例のオプションで「大系列ごと」か「小系列ごと」を選べるようにすればいい。 -> つまりこれも凡例の実装側で悩む管轄の話で、この数式ツール実装の時点で悩む必要はない。
* 数式は設定ファイルで保存できてもいい。ファイルパスとは違って外部に依存せずソフト内で閉じてる情報だし、特定の数式を色んなファイルに重ねて表示したいような解析シーンはよくあるし。将来的に。

## ちょっと思いつき系

* z(x,y) で const 入れたらエラー。たぶんZ値の範囲がストレートに0になってる。
  そういえばVer.6の方ではそういう際の範囲の「厚みもたせ」をまだ実装してなかった気がする。
  z = const の平面は数学入門とかで描くのでエラーではなく範囲に厚みをもたせるべき。

* マトリックス書式のパターンをどっちデフォルトにするかを、ファイル読み込み/データ貼り付け画面で選択できた方が良いが、そうすると config のどこに入れるべきか
  * DataConfiguration がストレートかと
    -> あっちは現在開いているデータの系列情報とかを持ってるけど、管轄がちょっと違うような気もする。
       -> サブ管轄を分ければ全然おかしくないような気もする。
          データをどう開くかという設定と、現在開いているデータが何かという一時的な状態バッファ。
          後者がむしろ config としてあるべきかどうかという議論があったが結果的に入った。
          なので前者がむしろ王道的で、堂々と入っていいでしょ。むしろ議論の余地あるのは後者で。

* 済: 範囲の調性、自動調整がONの場合はテキストフィールドを操作できないようにすべき。新UIでの方針に揃えると。
  5.x 互換の挙動は初見で慣れが要るし、変えてもいいと思う。上記の変更なら慣れたユーザーさんも「あーなるほどそうなったのか」ってすぐ分かるだろうし。

* 済: 上記に付随: そうするなら、併せてAPIでの setXRange とかは自動で setXAutoRangeEnabled(false) するようにして、それを明記すべき。

     -> それはいいのだろうか？

        -> setXTicks とかも TickerMode を自動で MANUAL に変えるし、こういう利便性APIは、使うのに必用な設定変更は自動でやる感じでいいでしょ。

        -> 互換についても、「setXAutoRangeEnabled(true) のまま setXRange して、その後も setXAutoRangeEnabled(true) が効いたままになってほしい」
           って相当変な使い方だし、そのレベルのニッチな使い方における変化は、5.x -> 6.0 の互換検証案内マニュアルにでも載せておけば大丈夫な範囲だと思う。
           
           で、むしろ setXRange したのにプロット毎に変わってしまう挙動のままの方が、API所見ユーザーにとっては辛い挙動なのでは。仕様書読む人しか対策分からないし。

    * LegendConfig の autoGenerateRegend と setLabelText のシンクロ化は？
      -> configコンテナはそういうのやるべきではない。あれは表層APIではなく、Model層の状態コンテナであり、それを直接いじれる機能なので。
         しかもUIとして「自動生成がONになっているが、グレーアウトしているテキストエリア内に labelTexts は設定されてて見えてる」っていう状態は普通に存在するし、config で表現可能である必用がある。

         -> 済: しかしそろそろ最上層に setLegendLabels(String[]) APIを実装すべきで、そっちでは autoLegendGenerationEnabled を自動で false にすべき。
            -> setLegendLabels(String[]) は少し冗長なので setLegends(String[]) にした。
            *  あと、このAPIを実装して思ったが、やはり config コンテナ層の setter で自動的に auto 系フラグを disable にすべきではない。
               それはAPIハンドラの層でやるべき。config コンテナの層でやると見通しが非常にややこしくなりそうな気配を感じた。

    * 描画エンジンAPIの Params でも、setAutoColorEnabled(true) なのに setColor しても効かないっていう挙動があるので、自動設定にしては？
      -> まあそれはやってもいいかなあ。悩むライン。
      -> 時間置いたけどどうだろうなあ。ほんと悩むなあそれは。概念的に利便性優先APIか設定コンテナの亜種なのか微妙なライン。というかちょうど境界で。詳細引数コンテナだし。

* 済: Vnano.jar、内蔵の数式プロット機能（外部スクリプトではない）に使ってるからもうエンジン自体も RinearnGraph3D.jar 内に入れ込んでしまった方がいいのでは？
  アプリ内に RinearnGraph3D.jar を組み込んで使う用途で、一発でいけるようになる。現状だと lib/app-dependency から Vnano.jar も引っ張ってこないといけない。
  で、RinearnGraph3D.jar を組み込む用途だと、数式も描ければ描きたいだろうし、 Vnano.jar も大抵は居るでしょ。

  * 確かに。標準プラグインはどうすべき？
    -> 同じ理由で Math 系は RinearnGraph3D.jar 内に入れといてもいいかな。
       ぜんぶ使える必用はないけれど。追加で使いたいやつは自力で追加してもらえばいい。標準でよく使う数式プラグインくらいは入れといた方がいいかも。

    * VnanoConfiguration とかで設定できてもいい。GUIだと「Vnanoスクリプトエンジン設定」か。独自実装プラグインやライブラリはそっちで指定し、SET を押すと確認メッセージ出したうえで lib/VnanoLibraryList.txt とかを書き換える。
      無ければその時に「フォルダや設定ファイルが指定位置にありません」って出す。アプリ実装する人はそこで気付けるしそれでいいかと。

* EnvironmentConfiguration, SystemConfiguration とかに変えるべき？ というか命名時も絶対思い浮かんだはずだけど、なんで採用しなかった？
  綴りが長て読み書きコスト高く、非直感的で抽象的な命名で、さらにメッセージの言語ロケールの取得とかで頻繁に参照する。もうちょいなんとかすべきかも。

  -> いやでも走りながら考えてきたらやっぱUIでは「環境設定」即ち「Environment Settings」が良い気がしてきたし、
     それだとコンテナが EnvironmentConfiguration になるのは妥当な気がする。
     UIでメニューに「環境設定」と「システム設定」がある時、どっちが分かりやすいか？って話。日本語/英語とか切り替えるのに。前者では。

### 長い脳内議論はこっちで


